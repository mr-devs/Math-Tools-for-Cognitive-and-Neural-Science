
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Question_3</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-09-24"><meta name="DC.source" content="Question_3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Math Tools I - HW #1 - Question 3: Geometry of Linear Transformations</a></li><li><a href="#2">(a) Create function PlotVec2</a></li><li><a href="#3">3.b Create the function venLenAngle</a></li><li><a href="#4">3.c Use PlotVec2 to put basis vectors through the svd transform step-by-step</a></li><li><a href="#5">3.d Create a Circle Matrix, Plot it, Then Plot Again and Again after SVD Transforms from Previous Problem Matrix</a></li></ul></div><h2 id="1">Math Tools I - HW #1 - Question 3: Geometry of Linear Transformations</h2><pre class="codeinput"><span class="comment">% Purpose: This code has been written to wrestle with question 3 of the</span>
<span class="comment">% first homework of math tools I.</span>

<span class="comment">% Author: Matthew DeVerna</span>

<span class="comment">% Date: 09/24/19</span>
</pre><h2 id="2">(a) Create function PlotVec2</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">a) Create the function PlotVec2 that takes in a matrix of height 2 and plots
</span><span class="comment">each column vector from this matrix on a 2-dimensional axes. It sohuld
</span><span class="comment">check that the matrix argument has height two, signaling an error if not.
</span><span class="comment">Vectors should be plotted as a line from the origin to the vector position,
</span><span class="comment">using circle or other symbol to denote the "head". It should also draw the
</span><span class="comment">x and y axes, extending from -1 to 1. The two axes should be equal size, so
</span><span class="comment">that horizontal units are equal to vertical units.
</span><span class="comment">
</span><span class="comment">%}
</span>
<span class="comment">% Due to the nature of the randn function, there can certainly be random</span>
<span class="comment">% numbers that are greater (or smaller) than 1 (or -1). In order to combat</span>
<span class="comment">% this aesthetic plotting issue. The absolute max value of each matrix will</span>
<span class="comment">% be found and then a square axis will be determined by that value + the</span>
<span class="comment">% below cushion value.</span>

cushion = .1 ;

<span class="comment">% Lets give this function a matrix with the proper height...</span>

rightSizeMAT = randn(2,12) ;
subplot(1,3,1)
PlotVec2(rightSizeMAT)
max_axis = max(max(abs(rightSizeMAT))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title(<span class="string">'First Try - Proper Input'</span>)

<span class="comment">% Lets create a matrix of the wrong shape - i.e. height =/= 2...</span>
incorrectSizeMAT = randn(12,2) ;

<span class="comment">% We know this is wrong, but we can transform it and see that the plotting</span>
<span class="comment">% function still works...</span>

subplot(1,3,2)
PlotVec2(incorrectSizeMAT')
max_axis = max(max(abs(incorrectSizeMAT))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title(<span class="string">'Second Try - Transposed Wrong Input'</span>)

<span class="comment">% However, if we don't do that, we see how the function handles matrices</span>
<span class="comment">% that have been submitted to plot with the wrong dimensions.</span>

<span class="comment">% It seems like this error test keeps the rest of my code from running,</span>
<span class="comment">% feel free to uncomment and try it yourself, but all of my answers below</span>
<span class="comment">% do not publish if I keep this in here.</span>

<span class="comment">% subplot(1,3,3)</span>
<span class="comment">% title('Wrong Dimensions')</span>
<span class="comment">% PlotVec2(incorrectSizeMAT)</span>
</pre><img vspace="5" hspace="5" src="Question_3_01.png" alt=""> <h2 id="3">3.b Create the function venLenAngle</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">Write a second function vecLenAngle that takes two vectors as arguments and
</span><span class="comment">returns the length of each vector, as well as the angle between them.
</span><span class="comment">Decide how you would like to handle cases when one (or both) vectors have
</span><span class="comment">zero length.
</span><span class="comment">
</span><span class="comment">NOTE:
</span><span class="comment">    - This function can take row or column vectors.
</span><span class="comment">    - Vectors with zero length are returned as such and it is assumed that
</span><span class="comment">    the angle between the vectors is zero - as you cannot have an angle
</span><span class="comment">    between two vectors when there is only one vector :).
</span><span class="comment">%}
</span>
<span class="comment">% First, we show that the function works with vectors of the same length...</span>
vec1 = rand(12,1) ;
vec2 = rand(1,12) ;

[len1, len2, Angle] = vecLenAngle(vec1,vec2);

disp(<span class="string">'Vectors with different dimensions'</span>)

fprintf(<span class="string">'vecLen1 = %f \n vecLen2 = %f \n Angle = %f'</span>, len1, len2,Angle)

<span class="comment">% For good measure, we show that the function works when the initial</span>
<span class="comment">% shapes match as well...</span>

vec1 = rand(12,1) ;
vec2 = rand(12,1) ;

[len1, len2, Angle] = vecLenAngle(vec1,vec2);

fprintf(<span class="string">'\n\nVectors with the same dimensions'</span>)

fprintf(<span class="string">'vecLen1 = %f \n vecLen2 = %f \n Angle = %f'</span>, len1, len2,Angle)

<span class="comment">% Now, we show that the function throws errors for vectors of different length...</span>

<span class="comment">% I commented this out as well, for the same reason as above.</span>

<span class="comment">% vec1 = rand(12,1) ;</span>
<span class="comment">% vec2 = rand(1,10) ;</span>
<span class="comment">%</span>
<span class="comment">% vecLenAngle(vec1,vec2)</span>
</pre><pre class="codeoutput">Vectors with different dimensions
vecLen1 = 2.218479 
 vecLen2 = 2.062009 
 Angle = 16.891681

Vectors with the same dimensionsvecLen1 = 1.593324 
 vecLen2 = 2.385814 
 Angle = 45.387597</pre><h2 id="4">3.c Use PlotVec2 to put basis vectors through the svd transform step-by-step</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">Generate a random 2x2 matrix M, and decompose it using the SVD, M = USV^T. Now
</span><span class="comment">examine the action of this sequence of transformations on the two &#8220;standard basis&#8221;
</span><span class="comment">vectors, {&#710;e_1, &#710;e_2}. Specifically, use vecLenAngle to examine the lengths and
</span><span class="comment">angle between two basis vectors &#710;e_n, the two vectors V^T &#710;e_n, the two vectors
</span><span class="comment">SV^T &#710;e_n, and the two vectors USV^T &#710;e_n. Do these values change, and if so,
</span><span class="comment">after which transformation? Verify this is consistent with their visual appearance
</span><span class="comment">by plotting each pair using plotVec2.
</span><span class="comment">%}
</span>
<span class="comment">% Create a random 2x2 matrix</span>
randMAT = randn(2) ;

subplot(2,3,1)
PlotVec2(randMAT);
title(<span class="string">'Original Matrix'</span>);
max_axis = max(max(abs(randMAT))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
grid <span class="string">on</span>

<span class="comment">% Decompes it utilizing the SVD</span>
[U,S,V] = svd(randMAT) ;

<span class="comment">% Create the two standard basis vectors</span>
e_1 = [1;0] ;
e_2 = [0;1] ;

<span class="comment">% Examine the length &amp; angle between the basis vectors</span>
subplot(2,3,2)
basis_values = vecLenAngle(e_1,e_2) ;
basis_combined = [e_1,e_2] ;
PlotVec2(basis_combined);
max_axis = max(max(abs(basis_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title(<span class="string">'Basis Transform'</span>);
grid <span class="string">on</span>

<span class="comment">% Now do this at each step of the transformation...</span>

<span class="comment">% 1. V^T  : Examine the length &amp; angle between the V^T*e_n</span>

V_transform1 = V'*e_1 ;
V_transform2 = V'*e_2 ;

[len1, len2, Angle] = vecLenAngle(V_transform1,V_transform2);

fprintf(<span class="string">'\n\nStep 1: V'' Transform  (Rotate)\n'</span>)

fprintf(<span class="string">'vecLen1 = %f \n vecLen2 = %f \n Angle = %f'</span>, len1, len2,Angle)

subplot(2,3,4)
V_combined = [V_transform1,V_transform2] ;
PlotVec2(V_combined);
max_axis = max(max(abs(V_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title(<span class="string">'Step 1: V'' Transform'</span>);
grid <span class="string">on</span>

<span class="comment">% 2. SV^T : Examine the length &amp; angle between the SV^T*e_n</span>

SV_transform1 = S*V_transform1 ;
SV_transform2 = S*V_transform2 ;
[len1, len2, Angle] = vecLenAngle(SV_transform1,SV_transform2);

fprintf(<span class="string">'\n\nStep 2: SV'' Transform (Stretch/Shrink)\n'</span>)

fprintf(<span class="string">'vecLen1 = %f \n vecLen2 = %f \n Angle = %f'</span>, len1, len2,Angle)

subplot(2,3,5)
SV_combined = [SV_transform1,SV_transform2] ;
PlotVec2(SV_combined);
max_axis = max(max(abs(SV_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title(<span class="string">'Step 2: SV'' Transform'</span>);
grid <span class="string">on</span>

<span class="comment">% 3. USV^T: Examine the length &amp; angle between the USV^T*e_n</span>

USV_transform1 = U*SV_transform1 ;
USV_transform2 = U*SV_transform2 ;
[len1, len2, Angle] = vecLenAngle(USV_transform1,USV_transform2);

fprintf(<span class="string">'\n\nStep 3: USV'' Transform (Rotate)\n'</span>)

fprintf(<span class="string">'vecLen1 = %f \n vecLen2 = %f \n Angle = %f'</span>, len1, len2,Angle)


subplot(2,3,6)
USV_combined = [USV_transform1,USV_transform2] ;
PlotVec2(USV_combined);
max_axis = max(max(abs(USV_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title(<span class="string">'Step 3: USV'' Transform'</span>);
grid <span class="string">on</span>

test = round(USV_combined,6) == round(randMAT,6);

answer = <span class="string">'\n\nSubjecting a matrix of basis vectors to the SVD\n of another vector returns the non-decomposed\n original matrix.\n'</span>;

<span class="keyword">if</span> test == true
    fprintf(answer)
<span class="keyword">else</span>
    fprintf(<span class="string">'Your code is broken, fix the calculations'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">

Step 1: V' Transform  (Rotate)
vecLen1 = 1.000000 
 vecLen2 = 1.000000 
 Angle = 90.000000

Step 2: SV' Transform (Stretch/Shrink)
vecLen1 = 1.645630 
 vecLen2 = 3.779531 
 Angle = 33.786370

Step 3: USV' Transform (Rotate)
vecLen1 = 1.645630 
 vecLen2 = 3.779531 
 Angle = 33.786370

Subjecting a matrix of basis vectors to the SVD
 of another vector returns the non-decomposed
 original matrix.
</pre><img vspace="5" hspace="5" src="Question_3_02.png" alt=""> <h2 id="5">3.d Create a Circle Matrix, Plot it, Then Plot Again and Again after SVD Transforms from Previous Problem Matrix</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">Generate a data matrix P with 65 columns containing 2-dimensional unit-vectors &#710;u_n =
</span><span class="comment">[cos(?n); sin(?n)], and ?n = 2pin/64, n = 0, 1, ... , 64.[Don&#8217;t use a for loop!
</span><span class="comment">Create a vector containing the values of ?n. ] Plot a single blue curve through these
</span><span class="comment">points, and a red star (asterisk) at the location of the first point. Consider the action
</span><span class="comment">of the matrix M from the previous problem on this set of points. In particular, apply
</span><span class="comment">the SVD transformations one at a time to full set of points (again, think of a way to do
</span><span class="comment">this without using a for loop!), plot them, and describe what geometric changes you see
</span><span class="comment">(and why).
</span><span class="comment">%}
</span>
n = 0:64;
thetas_ = (2*pi) * n ;
thetas = thetas_ / 64 ;
COS_SINE = [cos(thetas) ; sin(thetas)] ;

figure ;
subplot(2,3,2) ;
plot(COS_SINE(1,1), COS_SINE(2,1), <span class="string">'Marker'</span>, <span class="string">'*'</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'r'</span>, <span class="string">'MarkerSize'</span>, 10)
hold <span class="string">on</span>
plot(COS_SINE(1,:), COS_SINE(2,:), <span class="string">'b-'</span>) ;
axis <span class="string">equal</span>
title(<span class="string">'Orig. COS_ SINE Matrix Values'</span>)
max_axis = max(max(abs(COS_SINE))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
xlabel(<span class="string">'x-axis'</span>)
ylabel(<span class="string">'y-axis'</span>)

<span class="comment">% Plot the matrix step by step after each SVD transformation step</span>

V_transform_circle = V'*COS_SINE ;

subplot(2,3,4) ;
plot(V_transform_circle(1,1), V_transform_circle(2,1), <span class="string">'Marker'</span>, <span class="string">'*'</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'r'</span>, <span class="string">'MarkerSize'</span>, 10)
hold <span class="string">on</span>
plot(V_transform_circle(1,:), V_transform_circle(2,:), <span class="string">'b-'</span>) ;
axis <span class="string">equal</span>
title(<span class="string">'V'' Transform'</span>)
max_axis = max(max(abs(V_transform_circle))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
xlabel(<span class="string">'x-axis'</span>)
ylabel(<span class="string">'y-axis'</span>)

SV_transform_circle = S*(V'*COS_SINE) ;

subplot(2,3,5) ;
plot(SV_transform_circle(1,1), SV_transform_circle(2,1), <span class="string">'Marker'</span>, <span class="string">'*'</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'r'</span>, <span class="string">'MarkerSize'</span>, 10)
hold <span class="string">on</span>
plot(SV_transform_circle(1,:), SV_transform_circle(2,:), <span class="string">'b-'</span>) ;
axis <span class="string">equal</span>
title(<span class="string">'SV'' Transform'</span>)
xlabel(<span class="string">'x-axis'</span>)
ylabel(<span class="string">'y-axis'</span>)
max_axis = max(max(abs(SV_transform_circle))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;

USV_transform_circle = U*(S*(V'*COS_SINE)) ;

subplot(2,3,6) ;
plot(USV_transform_circle(1,1), USV_transform_circle(2,1), <span class="string">'Marker'</span>, <span class="string">'*'</span>, <span class="string">'MarkerEdgeColor'</span>, <span class="string">'r'</span>, <span class="string">'MarkerSize'</span>, 10)
hold <span class="string">on</span>
plot(USV_transform_circle(1,:), USV_transform_circle(2,:), <span class="string">'b-'</span>) ;
axis <span class="string">equal</span>
title(<span class="string">'USV'' Transform'</span>)
xlabel(<span class="string">'x-axis'</span>)
ylabel(<span class="string">'y-axis'</span>)
max_axis = max(max(abs(USV_transform_circle))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;

answer = <span class="string">'First Step = Rotate \n\nSecond Step = Stretch \n\nThird Step = Rotate Again'</span>;

sprintf(answer)
</pre><pre class="codeoutput">
ans =

    'First Step = Rotate 
     
     Second Step = Stretch 
     
     Third Step = Rotate Again'

</pre><img vspace="5" hspace="5" src="Question_3_03.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Math Tools I - HW #1 - Question 3: Geometry of Linear Transformations

% Purpose: This code has been written to wrestle with question 3 of the
% first homework of math tools I.

% Author: Matthew DeVerna

% Date: 09/24/19
%% (a) Create function PlotVec2

%{
a) Create the function PlotVec2 that takes in a matrix of height 2 and plots
each column vector from this matrix on a 2-dimensional axes. It sohuld
check that the matrix argument has height two, signaling an error if not.
Vectors should be plotted as a line from the origin to the vector position,
using circle or other symbol to denote the "head". It should also draw the
x and y axes, extending from -1 to 1. The two axes should be equal size, so
that horizontal units are equal to vertical units.

%}

% Due to the nature of the randn function, there can certainly be random
% numbers that are greater (or smaller) than 1 (or -1). In order to combat
% this aesthetic plotting issue. The absolute max value of each matrix will
% be found and then a square axis will be determined by that value + the
% below cushion value. 

cushion = .1 ;

% Lets give this function a matrix with the proper height...

rightSizeMAT = randn(2,12) ;
subplot(1,3,1)
PlotVec2(rightSizeMAT)
max_axis = max(max(abs(rightSizeMAT))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title('First Try - Proper Input')

% Lets create a matrix of the wrong shape - i.e. height =/= 2...
incorrectSizeMAT = randn(12,2) ;

% We know this is wrong, but we can transform it and see that the plotting
% function still works...

subplot(1,3,2)
PlotVec2(incorrectSizeMAT')
max_axis = max(max(abs(incorrectSizeMAT))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title('Second Try - Transposed Wrong Input')

% However, if we don't do that, we see how the function handles matrices
% that have been submitted to plot with the wrong dimensions.

% It seems like this error test keeps the rest of my code from running,
% feel free to uncomment and try it yourself, but all of my answers below
% do not publish if I keep this in here.

% subplot(1,3,3)
% title('Wrong Dimensions')
% PlotVec2(incorrectSizeMAT)

%% 3.b Create the function venLenAngle

%{
Write a second function vecLenAngle that takes two vectors as arguments and
returns the length of each vector, as well as the angle between them.
Decide how you would like to handle cases when one (or both) vectors have
zero length.

NOTE: 
    - This function can take row or column vectors.
    - Vectors with zero length are returned as such and it is assumed that
    the angle between the vectors is zero - as you cannot have an angle
    between two vectors when there is only one vector :).
%}

% First, we show that the function works with vectors of the same length...
vec1 = rand(12,1) ;
vec2 = rand(1,12) ;

[len1, len2, Angle] = vecLenAngle(vec1,vec2);

disp('Vectors with different dimensions')

fprintf('vecLen1 = %f \n vecLen2 = %f \n Angle = %f', len1, len2,Angle)

% For good measure, we show that the function works when the initial
% shapes match as well...

vec1 = rand(12,1) ;
vec2 = rand(12,1) ;

[len1, len2, Angle] = vecLenAngle(vec1,vec2);

fprintf('\n\nVectors with the same dimensions')

fprintf('vecLen1 = %f \n vecLen2 = %f \n Angle = %f', len1, len2,Angle)

% Now, we show that the function throws errors for vectors of different length...

% I commented this out as well, for the same reason as above. 

% vec1 = rand(12,1) ;
% vec2 = rand(1,10) ;
% 
% vecLenAngle(vec1,vec2)

%% 3.c Use PlotVec2 to put basis vectors through the svd transform step-by-step
%{
Generate a random 2x2 matrix M, and decompose it using the SVD, M = USV^T. Now
examine the action of this sequence of transformations on the two “standard basis”
vectors, {ˆe_1, ˆe_2}. Specifically, use vecLenAngle to examine the lengths and 
angle between two basis vectors ˆe_n, the two vectors V^T ˆe_n, the two vectors 
SV^T ˆe_n, and the two vectors USV^T ˆe_n. Do these values change, and if so, 
after which transformation? Verify this is consistent with their visual appearance 
by plotting each pair using plotVec2.
%}

% Create a random 2x2 matrix
randMAT = randn(2) ;

subplot(2,3,1)
PlotVec2(randMAT);
title('Original Matrix');
max_axis = max(max(abs(randMAT))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
grid on

% Decompes it utilizing the SVD
[U,S,V] = svd(randMAT) ;

% Create the two standard basis vectors
e_1 = [1;0] ;
e_2 = [0;1] ;

% Examine the length & angle between the basis vectors
subplot(2,3,2)
basis_values = vecLenAngle(e_1,e_2) ;
basis_combined = [e_1,e_2] ;
PlotVec2(basis_combined);
max_axis = max(max(abs(basis_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title('Basis Transform');
grid on

% Now do this at each step of the transformation...

% 1. V^T  : Examine the length & angle between the V^T*e_n

V_transform1 = V'*e_1 ;
V_transform2 = V'*e_2 ;

[len1, len2, Angle] = vecLenAngle(V_transform1,V_transform2);

fprintf('\n\nStep 1: V'' Transform  (Rotate)\n')

fprintf('vecLen1 = %f \n vecLen2 = %f \n Angle = %f', len1, len2,Angle)

subplot(2,3,4)
V_combined = [V_transform1,V_transform2] ;
PlotVec2(V_combined);
max_axis = max(max(abs(V_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title('Step 1: V'' Transform');
grid on

% 2. SV^T : Examine the length & angle between the SV^T*e_n

SV_transform1 = S*V_transform1 ;
SV_transform2 = S*V_transform2 ;
[len1, len2, Angle] = vecLenAngle(SV_transform1,SV_transform2);

fprintf('\n\nStep 2: SV'' Transform (Stretch/Shrink)\n')

fprintf('vecLen1 = %f \n vecLen2 = %f \n Angle = %f', len1, len2,Angle)

subplot(2,3,5)
SV_combined = [SV_transform1,SV_transform2] ;
PlotVec2(SV_combined);
max_axis = max(max(abs(SV_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title('Step 2: SV'' Transform');
grid on

% 3. USV^T: Examine the length & angle between the USV^T*e_n

USV_transform1 = U*SV_transform1 ;
USV_transform2 = U*SV_transform2 ;
[len1, len2, Angle] = vecLenAngle(USV_transform1,USV_transform2);

fprintf('\n\nStep 3: USV'' Transform (Rotate)\n')

fprintf('vecLen1 = %f \n vecLen2 = %f \n Angle = %f', len1, len2,Angle)


subplot(2,3,6)
USV_combined = [USV_transform1,USV_transform2] ;
PlotVec2(USV_combined);
max_axis = max(max(abs(USV_combined))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
title('Step 3: USV'' Transform');
grid on

test = round(USV_combined,6) == round(randMAT,6);

answer = '\n\nSubjecting a matrix of basis vectors to the SVD\n of another vector returns the non-decomposed\n original matrix.\n';

if test == true
    fprintf(answer)
else
    fprintf('Your code is broken, fix the calculations')
end

%% 3.d Create a Circle Matrix, Plot it, Then Plot Again and Again after SVD Transforms from Previous Problem Matrix

%{
Generate a data matrix P with 65 columns containing 2-dimensional unit-vectors ˆu_n =
[cos(?n); sin(?n)], and ?n = 2pin/64, n = 0, 1, ... , 64.[Don’t use a for loop!
Create a vector containing the values of ?n. ] Plot a single blue curve through these
points, and a red star (asterisk) at the location of the first point. Consider the action
of the matrix M from the previous problem on this set of points. In particular, apply
the SVD transformations one at a time to full set of points (again, think of a way to do
this without using a for loop!), plot them, and describe what geometric changes you see
(and why).
%}

n = 0:64;
thetas_ = (2*pi) * n ;
thetas = thetas_ / 64 ;
COS_SINE = [cos(thetas) ; sin(thetas)] ;

figure ;
subplot(2,3,2) ;
plot(COS_SINE(1,1), COS_SINE(2,1), 'Marker', '*', 'MarkerEdgeColor', 'r', 'MarkerSize', 10)
hold on
plot(COS_SINE(1,:), COS_SINE(2,:), 'b-') ;
axis equal
title('Orig. COS_ SINE Matrix Values')
max_axis = max(max(abs(COS_SINE))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
xlabel('x-axis')
ylabel('y-axis')

% Plot the matrix step by step after each SVD transformation step

V_transform_circle = V'*COS_SINE ;

subplot(2,3,4) ;
plot(V_transform_circle(1,1), V_transform_circle(2,1), 'Marker', '*', 'MarkerEdgeColor', 'r', 'MarkerSize', 10)
hold on
plot(V_transform_circle(1,:), V_transform_circle(2,:), 'b-') ;
axis equal
title('V'' Transform')
max_axis = max(max(abs(V_transform_circle))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;
xlabel('x-axis')
ylabel('y-axis')

SV_transform_circle = S*(V'*COS_SINE) ;

subplot(2,3,5) ;
plot(SV_transform_circle(1,1), SV_transform_circle(2,1), 'Marker', '*', 'MarkerEdgeColor', 'r', 'MarkerSize', 10)
hold on
plot(SV_transform_circle(1,:), SV_transform_circle(2,:), 'b-') ;
axis equal
title('SV'' Transform')
xlabel('x-axis')
ylabel('y-axis')
max_axis = max(max(abs(SV_transform_circle))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;

USV_transform_circle = U*(S*(V'*COS_SINE)) ;

subplot(2,3,6) ;
plot(USV_transform_circle(1,1), USV_transform_circle(2,1), 'Marker', '*', 'MarkerEdgeColor', 'r', 'MarkerSize', 10)
hold on
plot(USV_transform_circle(1,:), USV_transform_circle(2,:), 'b-') ;
axis equal
title('USV'' Transform')
xlabel('x-axis')
ylabel('y-axis')
max_axis = max(max(abs(USV_transform_circle))) ;
cushion = .1 ;
xlim([-max_axis-cushion max_axis+cushion]) ;
ylim([-max_axis-cushion max_axis+cushion]) ;

answer = 'First Step = Rotate \n\nSecond Step = Stretch \n\nThird Step = Rotate Again';

sprintf(answer)


##### SOURCE END #####
--></body></html>