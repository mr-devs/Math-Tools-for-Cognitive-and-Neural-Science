
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>4 A Simple Visual Neuron</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-09-24"><meta name="DC.source" content="Question_4.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>4 A Simple Visual Neuron</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Question</a></li><li><a href="#2">(a) Is this system linear? If so, how do you know? If not, provide a counter-example.</a></li><li><a href="#3">(b) What unit-length stimulus vector elicits the largest response in the neuron?</a></li><li><a href="#4">(c) What physically-realizable unit-length stimulus vector produces the smallest response in this neuron?</a></li></ul></div><h2 id="1">Question</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">Suppose a retinal neuron in a particular species of toad generates
</span><span class="comment">responses that are a weighted sum of the (positive-valued) intensities of light
</span><span class="comment">that is sensed at 6 localized regions of the retina. The weight vector is
</span><span class="comment">[1, 3, 8, 8, 3, 1].
</span><span class="comment">%}
</span>
weighting_vector = [1;3;8;8;3;1] ;
</pre><h2 id="2">(a) Is this system linear? If so, how do you know? If not, provide a counter-example.</h2><pre class="codeinput"><span class="comment">%{
</span><span class="comment">
</span><span class="comment">This system must be linear because the system's operations (a weighted sum) are
</span><span class="comment">multiplication and addition. To be linear, a system must obey the rules
</span><span class="comment">of superposition - homogeneity and additivity - both multiplication and
</span><span class="comment">addition are allowed within a linear system.
</span><span class="comment">
</span><span class="comment">We can also prove this by creating two different input vectors and testing
</span><span class="comment">whether or not they obey the laws of super position.
</span><span class="comment">
</span><span class="comment">By creating a second input which is input_stumli1 scaled by 2, we can see
</span><span class="comment">if the response obeys the laws of homoegeneity.
</span><span class="comment">
</span><span class="comment">%}
</span>
input_stimuli1 = [1,0,0,0,0,0] ;
input_stimuli2 = [2,0,0,0,0,0] ;


<span class="comment">% Because input_stimuli2 is input_stimuli1 scaled by 2, putting these</span>
<span class="comment">% inputs into the system should return outputs which are also scaled by two</span>
<span class="comment">% - if the system is linear.</span>

output1 = sum((input_stimuli1 * 2) * weighting_vector)
output2 = sum((input_stimuli2 * 2) * weighting_vector)

<span class="comment">% Now we can check if output1 * 2 = output 2</span>

<span class="keyword">if</span> output1 * 2 == output2
    disp(<span class="string">'The system is linear!'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'The system is NOT linear!'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">
output1 =

     2


output2 =

     4

The system is linear!
</pre><h2 id="3">(b) What unit-length stimulus vector elicits the largest response in the neuron?</h2><p>Explain how you arrived at your answer.</p><pre class="codeinput"><span class="comment">%{
</span><span class="comment">If we look at this problem as getting the magnitude of a projection onto a
</span><span class="comment">unit vector we can see quicky that the larger the ANGLE between the
</span><span class="comment">weighting vector and the unit vector, the smaller a response we will get
</span><span class="comment">from the frog's lovely neuron. Thus, we should take input the unit_vector
</span><span class="comment">that is ON TOP OF the weighting vector itself. The vector going in the
</span><span class="comment">other direction would not physically realizable (it would be negative).
</span><span class="comment">
</span><span class="comment">Said another way, we should simply find the weighting vectors unit vector
</span><span class="comment">by dividing by it's length.
</span><span class="comment">%}
</span>
length_weighting_vector = sqrt(weighting_vector'*weighting_vector) ;

unit_weight_vector = weighting_vector  / length_weighting_vector ;

largestNeuronResponse = weighting_vector'*unit_weight_vec ;

answer = <span class="string">'The largest response that we can get from this frog''s neuron = %f.'</span> ;

sprintf(answer,largestNeuronResponse)
</pre><pre class="codeoutput">
ans =

    'The largest response that we can get from this frog's neuron = 12.165525.'

</pre><h2 id="4">(c) What physically-realizable unit-length stimulus vector produces the smallest response in this neuron?</h2><p>- Explain.</p><pre class="codeinput"><span class="comment">%{
</span><span class="comment">Since this linear system takes the following form:
</span><span class="comment">
</span><span class="comment">response = w1*s1 + w2*s2 + ... + w_n*s_n
</span><span class="comment">
</span><span class="comment">where:
</span><span class="comment">w = the weighting vector and
</span><span class="comment">s = the stimulus input
</span><span class="comment">
</span><span class="comment">this takes the more concrete form of:
</span><span class="comment">
</span><span class="comment">response = 1*s1 + 3*s2 + 8*s_3 + 8*s_4 + 3*s_5 + 1*s_6
</span><span class="comment">
</span><span class="comment">As alluded to in part (b) taking a unit vector which creates the largest
</span><span class="comment">angle between the weighting vector and the unit vector gives you the
</span><span class="comment">SMALLEST response. This is similar to projecting onto an orthogonal unit
</span><span class="comment">vector.
</span><span class="comment">
</span><span class="comment">Given the form of the response system, we can cycle through orthogonal
</span><span class="comment">bases and clearly see that input_stumulus1 and input_stimulus6 gives us
</span><span class="comment">identical answers, but they are the lowest.
</span><span class="comment">
</span><span class="comment">%}
</span>
input_stimuli1 = [1,0,0,0,0,0] ;
input_stimuli2 = [0,1,0,0,0,0] ;
input_stimuli3 = [0,0,1,0,0,0] ;
input_stimuli4 = [0,0,0,1,0,0] ;
input_stimuli5 = [0,0,0,0,1,0] ;
input_stimuli6 = [0,0,0,0,0,1] ;

output1 = input_stimuli1 * weighting_vector
output2 = input_stimuli2 * weighting_vector
output3 = input_stimuli3 * weighting_vector
output4 = input_stimuli4 * weighting_vector
output5 = input_stimuli5 * weighting_vector
output6 = input_stimuli6 * weighting_vector

answer = <span class="string">'One of the two input vectors which gives the lowest answer is input_stimulus6'</span>

sprintf(answer)
</pre><pre class="codeoutput">
output1 =

     1


output2 =

     3


output3 =

     8


output4 =

     8


output5 =

     3


output6 =

     1


answer =

    'One of the two input vectors which gives the lowest answer is input_stimulus6'


ans =

    'One of the two input vectors which gives the lowest answer is input_stimulus6'

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% 4 A Simple Visual Neuron


%% Question
%{
Suppose a retinal neuron in a particular species of toad generates
responses that are a weighted sum of the (positive-valued) intensities of light
that is sensed at 6 localized regions of the retina. The weight vector is 
[1, 3, 8, 8, 3, 1]. 
%}

weighting_vector = [1;3;8;8;3;1] ;

%% (a) Is this system linear? If so, how do you know? If not, provide a counter-example.
%{ 

This system must be linear because the system's operations (a weighted sum) are
multiplication and addition. To be linear, a system must obey the rules
of superposition - homogeneity and additivity - both multiplication and
addition are allowed within a linear system.

We can also prove this by creating two different input vectors and testing
whether or not they obey the laws of super position.

By creating a second input which is input_stumli1 scaled by 2, we can see
if the response obeys the laws of homoegeneity.

%}

input_stimuli1 = [1,0,0,0,0,0] ;
input_stimuli2 = [2,0,0,0,0,0] ;


% Because input_stimuli2 is input_stimuli1 scaled by 2, putting these
% inputs into the system should return outputs which are also scaled by two
% - if the system is linear.

output1 = sum((input_stimuli1 * 2) * weighting_vector)
output2 = sum((input_stimuli2 * 2) * weighting_vector)

% Now we can check if output1 * 2 = output 2

if output1 * 2 == output2
    disp('The system is linear!')
else
    disp('The system is NOT linear!')
end

%% (b) What unit-length stimulus vector elicits the largest response in the neuron?
% Explain how you arrived at your answer.

%{
If we look at this problem as getting the magnitude of a projection onto a
unit vector we can see quicky that the larger the ANGLE between the
weighting vector and the unit vector, the smaller a response we will get
from the frog's lovely neuron. Thus, we should take input the unit_vector
that is ON TOP OF the weighting vector itself. The vector going in the
other direction would not physically realizable (it would be negative).

Said another way, we should simply find the weighting vectors unit vector
by dividing by it's length.
%}

length_weighting_vector = sqrt(weighting_vector'*weighting_vector) ;

unit_weight_vector = weighting_vector  / length_weighting_vector ;

largestNeuronResponse = weighting_vector'*unit_weight_vec ;

answer = 'The largest response that we can get from this frog''s neuron = %f.' ;

sprintf(answer,largestNeuronResponse)

%% (c) What physically-realizable unit-length stimulus vector produces the smallest response in this neuron?
% - Explain. 
%{
Since this linear system takes the following form:

response = w1*s1 + w2*s2 + ... + w_n*s_n

where:
w = the weighting vector and
s = the stimulus input

this takes the more concrete form of:

response = 1*s1 + 3*s2 + 8*s_3 + 8*s_4 + 3*s_5 + 1*s_6

As alluded to in part (b) taking a unit vector which creates the largest
angle between the weighting vector and the unit vector gives you the
SMALLEST response. This is similar to projecting onto an orthogonal unit
vector.

Given the form of the response system, we can cycle through orthogonal
bases and clearly see that input_stumulus1 and input_stimulus6 gives us
identical answers, but they are the lowest.

%}

input_stimuli1 = [1,0,0,0,0,0] ;
input_stimuli2 = [0,1,0,0,0,0] ;
input_stimuli3 = [0,0,1,0,0,0] ;
input_stimuli4 = [0,0,0,1,0,0] ;
input_stimuli5 = [0,0,0,0,1,0] ;
input_stimuli6 = [0,0,0,0,0,1] ;

output1 = input_stimuli1 * weighting_vector
output2 = input_stimuli2 * weighting_vector
output3 = input_stimuli3 * weighting_vector
output4 = input_stimuli4 * weighting_vector
output5 = input_stimuli5 * weighting_vector
output6 = input_stimuli6 * weighting_vector

answer = 'One of the two input vectors which gives the lowest answer is input_stimulus6'

sprintf(answer)
##### SOURCE END #####
--></body></html>